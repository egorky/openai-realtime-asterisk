; Asterisk Dialplan Configuration for ARI Speech-to-Text Application
;
; This dialplan context demonstrates how to invoke the ARI application
; and how to use the channel variables it sets.

[default]
; Example: Dial 1234 to test the speech recognition
exten => 1234,1,Goto(speech-recognition,start,1)

[speech-recognition]
; This context will be invoked by the ARI application named in your config (e.g., speech-to-text-app)
; The application name is configured in .env (ASTERISK_ARI_APP_NAME) and config/default.json

exten => start,1,NoOp(=== Initiating call to ARI Speech-to-Text Application ===)
    same => n,Answer()
    ; Send the call to the Stasis application (our Node.js app)
    ; The argument to Stasis() is the application name registered by the Node.js client.
    ; Make sure this matches ASTERISK_ARI_APP_NAME in your .env/config.
    same => n,Stasis(speech-to-text-app)
    ;
    ; --- Control returns here after the ARI application finishes ---
    ; The ARI application should set the following channel variables:
    ;   SPEECH_TEXT: The transcribed text from the user.
    ;   NO_SPEECH_TIMEOUT: Set to 'true' if no speech was detected by the VAD.
    ;

    same => n,NoOp(=== ARI Application Finished ===)
    same => n,NoOp(Raw SPEECH_TEXT variable: '${SPEECH_TEXT}')
    same => n,NoOp(Raw NO_SPEECH_TIMEOUT variable: '${NO_SPEECH_TIMEOUT}')
    same => n,NoOp(Raw DTMF_DIGITS variable: '${DTMF_DIGITS}') ; Log DTMF_DIGITS

    ; Prioritize DTMF_DIGITS
    same => n,GotoIf($[${ISNULL(${DTMF_DIGITS})}]?no_dtmf_input:dtmf_input_received)

exten => dtmf_input_received,1,NoOp(--- DTMF Digits Received: ${DTMF_DIGITS} ---)
    same => n,Log(NOTICE, Collected DTMF Digits: ${DTMF_DIGITS})
    same => n,Playback(sound:digits/received) ; Assuming 'digits/received.gsm' or similar exists
    same => n,Playback(sound:vm-goodbye)
    same => n,Hangup()

exten => no_dtmf_input,1,NoOp(--- No DTMF Digits, proceeding with speech/no-speech logic ---)
    ; Check if NO_SPEECH_TIMEOUT was set (this is the old logic, now under no_dtmf_input)
    same => n,GotoIf($["${NO_SPEECH_TIMEOUT}" = "true"]?no_speech_detected:speech_detected)

exten => no_speech_detected,1,NoOp(--- No speech was detected by ARI application ---)
    same => n,Playback(sound:silence-detected) ; Play a sound indicating silence (create this audio file)
    same => n,Playback(sound:vm-goodbye)
    same => n,Hangup()

exten => speech_detected,1,NoOp(--- Speech was detected by ARI application ---)
    ; Check if SPEECH_TEXT is empty or not (it might be empty even if speech activity was detected but no words recognized)
    same => n,GotoIf($[${ISNULL(${SPEECH_TEXT})}]?no_text_recognized:text_recognized)

exten => no_text_recognized,1,NoOp(--- Speech detected, but no text recognized or text is empty ---)
    same => n,Playback(sound:unrecognized) ; Play a sound indicating not recognized (create this audio file)
    same => n,Playback(sound:vm-goodbye)
    same => n,Hangup()

exten => text_recognized,1,NoOp(--- Transcribed text received: ${SPEECH_TEXT} ---)
    ; Example: Play back the recognized text using Asterisk's SayString or a TTS engine
    ; For simplicity, we'll just log it here. For actual playback:
    ; same => n,SayString(${SPEECH_TEXT}) ; Might require specific TTS setup
    ; Or, if you have Festival or another TTS configured:
    ; same => n,Festival('You said: ${SPEECH_TEXT}')
    same => n,Log(NOTICE, Transcribed Text: ${SPEECH_TEXT})
    same => n,Playback(sound:you-said) ; "You said..." (create this audio file)
    ; If using Festival or similar TTS, you might not need to play the text directly if SayString works.
    ; This is a placeholder for demonstrating usage.

    ; Example: Do something with the text, e.g., look it up in a database, route based on content, etc.
    ; For now, just play goodbye.
    same => n,Playback(sound:vm-goodbye)
    same => n,Hangup()

; It's good practice to have h extension for hangup handling if needed
exten => h,1,NoOp(Call ended in speech-recognition context)

; === Examples for ForceWaitingAudio and WaitingAudioMode ===
; These examples demonstrate how to set the channel variables from the dialplan
; to control the new forced waiting audio features in the Stasis application.

; Example 1: Forcing waiting audio with playFullBeforeDialplan mode
; - APP_AUDIO_FORCEWAITINGAUDIO=true: Tells the app to play waiting audio before greeting/recognition.
; - APP_AUDIO_WAITINGAUDIOMODE=playFullBeforeDialplan: The Stasis app will wait for this audio to complete
;   before proceeding with its own logic (e.g., playing a greeting or starting recognition).
exten => 2001,1,NoOp(Setting forced waiting audio with playFullBeforeDialplan mode)
    same => n,Set(APP_AUDIO_FORCEWAITINGAUDIO=true)
    same => n,Set(APP_AUDIO_WAITINGAUDIOMODE=playFullBeforeDialplan)
    ; Optional: Specify the waiting sound if different from the one in default.json or for this specific call
    ; same => n,Set(APP_AUDIO_WAITINGPATH=sounds/your-specific-waiting-sound)
    same => n,Stasis(speech-to-text-app) ; Replace with your Stasis app name if different
    same => n,NoOp(Returned from Stasis. Forced audio should have played in full.)
    ; ... continue with other dialplan logic based on SPEECH_TEXT etc. ...
    same => n,Hangup()

; Example 2: Forcing waiting audio with playAndTransfer mode
; - APP_AUDIO_FORCEWAITINGAUDIO=true: Tells the app to play waiting audio.
; - APP_AUDIO_WAITINGAUDIOMODE=playAndTransfer: The Stasis app will start playing the waiting audio
;   and then immediately return control to the dialplan by setting FORCED_WAITING_AUDIO_ACTIVE=true.
;   The dialplan is then responsible for stopping this audio when appropriate.
exten => 2002,1,NoOp(Setting forced waiting audio with playAndTransfer mode)
    same => n,Set(APP_AUDIO_FORCEWAITINGAUDIO=true)
    same => n,Set(APP_AUDIO_WAITINGAUDIOMODE=playAndTransfer)
    same => n,Stasis(speech-to-text-app) ; Replace with your Stasis app name if different

    ; --- Control returns here ALMOST IMMEDIATELY after Stasis starts the audio ---
    same => n,NoOp(Returned from Stasis. Forced audio active status: \${FORCED_WAITING_AUDIO_ACTIVE})

    ; Example: Wait for some event or time before stopping the audio
    ; For instance, you might bridge the call to an agent here.
    ; Once the agent answers, or some other condition is met, you'd stop the waiting audio.
    same => n,Wait(5) ; Placeholder: Simulate some dialplan activity while audio plays

    ; Check if forced audio was set to active by the Stasis app
    same => n,GotoIf($["\${FORCED_WAITING_AUDIO_ACTIVE}" = "true"]?stop_forced_audio:continue_dialplan)

same => n(stop_forced_audio),NoOp(FORCED_WAITING_AUDIO_ACTIVE is true. Stopping it now.)
    ; StopPlaytones() is a general way to stop audio played via Playback on the channel.
    ; This should stop the sound played by the Stasis application.
    same => n,StopPlaytones()
    same => n,Set(FORCED_WAITING_AUDIO_ACTIVE=false) ; Update the variable to reflect it's been handled
    same => n,NoOp(Forced audio stopped by dialplan.)
    same => n,Goto(continue_dialplan)

same => n(continue_dialplan),NoOp(Continuing dialplan logic after handling forced audio.)
    ; ... Your main call flow logic would go here ...
    ; For example, checking SPEECH_TEXT if recognition also ran, or bridging the call.
    same => n,NoOp(SPEECH_TEXT from Stasis app (if any recognition occurred): \${SPEECH_TEXT})
    same => n,Playback(sound:vm-goodbye)
    same => n,Hangup()

; Note: The Stasis application (speech-to-text-app) will also attempt to stop the forced waiting audio
; during its own fullCleanup sequence if the call is hung up while the audio is playing
; (especially in playAndTransfer mode). The dialplan's StopPlaytones here is for scenarios
; where the call flow continues in the dialplan and the dialplan decides when to stop the audio.
